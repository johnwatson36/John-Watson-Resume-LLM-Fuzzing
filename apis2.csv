api_name,parameters,parameter_descriptions,example_usage,temperature
torch.chunk,"['input_tensor', 'chunks', 'dim']","['Tensor to split.', 'Number of chunks to return.', 'Dimension along which to split tensor.']","torch.chunk(input_tensor, chunks, dim)",
torch.nn.functional.grid_sample,"['input', 'grid', 'mode', 'padding_mode', 'align_corners']","['Input tensor', 'Sample grid', ""Interpolation mode - 'bilinear' or 'nearest'"", ""Padding mode - 'zeros' or 'border'"", 'Bool flag indicating whether the output corners should be aligned']","torch.nn.functional.grid_sample(input, grid, mode, padding_mode, align_corners)",
torch.index_select,"['input', 'dim', 'index']","['Input tensor', 'Dimension to index', '1-D tensor containing the indices to index']","torch.index_select(input, dim, index)",
torch.utils.data.DataLoader,"['dataset', 'batch_size', 'shuffle', 'sampler', 'batch_sampler', 'num_workers', 'collate_fn', 'pin_memory', 'drop_last', 'timeout']","['Dataset from which to load the data', 'How many samples per batch to load', 'Set to True to have the data reshuffled at every epoch', 'Defines the strategy to draw samples from the dataset', 'Like sampler, but returns a batch of indices at a time', 'How many subprocesses to use for data loading', 'Merges a list of samples to form a mini-batch', 'If True, the data loader will copy tensors into CUDA pinned memory before returning them', 'Set to True to drop the last incomplete batch, if the dataset size is not divisible by the batch size', 'If positive, provides a timeout value for collecting a batch from workers']","torch.utils.data.DataLoader(dataset, batch_size, shuffle, sampler, batch_sampler, num_workers, collate_fn, pin_memory, drop_last, timeout)",
torch.fft,"['input', 'n', 'dim', 'norm']","['Input tensor', 'Length of FFT', 'Dimensions over which to compute the FFT', 'Normalization mode']","torch.fft(input, n, dim, norm)",
torch.bernoulli,"['input', 'generator']","['Input tensor', 'A Pytorch generator used to draw the random samples']","torch.bernoulli(input, generator)",
torch.linspace,"['start', 'end', 'steps', 'out', 'layout', 'device', 'requires_grad']","['Starting value of the sequence', 'End value of the sequence', 'Number of steps to generate', 'Output tensor', 'Layout of the tensor', 'Device on which to create the tensor', 'Flag indicating if the output requires gradients']","torch.linspace(start, end, steps, out, layout, device, requires_grad)",
torch.bmm,"['input', 'mat2']","['First batch of matrices to be multiplied', 'Second batch of matrices to be multiplied']","torch.bmm(input, mat2)",
torch.distributions.Categorical,"['probs', 'logits', 'validate_args']","['Event probabilities', 'Event log probabilities', 'Whether to enable validation or not']","torch.distributions.Categorical(probs, logits, validate_args)",
torch.nn.Conv2d,"['in_channels', 'out_channels', 'kernel_size', 'stride', 'padding', 'dilation', 'groups', 'bias', 'padding_mode']","['Number of channels in the input image', 'Number of channels produced by the convolution', 'Size of the convolving kernel', 'Stride of the convolution', 'Zero-padding added to both sides of the input', 'Spacing between kernel elements', 'Number of blocked connections from input channels to output channels', 'Whether the layer uses a bias', 'Padding mode to use']","torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding, dilation, groups, bias, padding_mode)",
